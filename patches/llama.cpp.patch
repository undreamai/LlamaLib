diff --git a/common/common.h b/common/common.h
index d6fd0d37a..ea2777d20 100644
--- a/common/common.h
+++ b/common/common.h
@@ -489,7 +489,9 @@ struct common_params {
     std::vector<std::string> api_keys;
 
     std::string ssl_file_key  = "";                                                                         // NOLINT
-    std::string ssl_file_cert = "";                                                                         // NOLINT
+    std::string ssl_file_cert = ""; 
+    std::string ssl_key  = "";                                                                         // NOLINT
+    std::string ssl_cert = "";                                                                         // NOLINT
 
     std::map<std::string, std::string> default_template_kwargs;
 
diff --git a/common/log.cpp b/common/log.cpp
index b17d2b62c..f33876340 100644
--- a/common/log.cpp
+++ b/common/log.cpp
@@ -21,7 +21,8 @@
 #    include <unistd.h>
 #endif // defined(_WIN32)
 
-int common_log_verbosity_thold = LOG_DEFAULT_LLAMA;
+void (*log_callback)(const char*) = nullptr;
+int common_log_verbosity_thold = -2;
 
 void common_log_set_verbosity_thold(int verbosity) {
     common_log_verbosity_thold = verbosity;
@@ -108,6 +109,7 @@ struct common_log_entry {
         }
 
         fprintf(fcur, "%s", msg.data());
+        if (log_callback) log_callback(msg.data());
 
         if (level == GGML_LOG_LEVEL_WARN || level == GGML_LOG_LEVEL_ERROR || level == GGML_LOG_LEVEL_DEBUG) {
             fprintf(fcur, "%s", g_col[COMMON_LOG_COL_DEFAULT]);
diff --git a/common/log.h b/common/log.h
index f0f8471b5..c1eb92d7e 100644
--- a/common/log.h
+++ b/common/log.h
@@ -36,6 +36,7 @@ enum log_colors {
     LOG_COLORS_ENABLED  = 1,
 };
 
+extern void (*log_callback)(const char*);
 // needed by the LOG_TMPL macro to avoid computing log arguments if the verbosity lower
 // set via common_log_set_verbosity()
 extern int common_log_verbosity_thold;
diff --git a/ggml/src/CMakeLists.txt b/ggml/src/CMakeLists.txt
index 6192a8704..e5c03ff28 100644
--- a/ggml/src/CMakeLists.txt
+++ b/ggml/src/CMakeLists.txt
@@ -136,18 +136,6 @@ endif()
 # posix_memalign came in POSIX.1-2001 / SUSv3
 # M_PI is an XSI extension since POSIX.1-2001 / SUSv3, came in XPG1 (1985)
 
-# Somehow in OpenBSD whenever POSIX conformance is specified
-# some string functions rely on locale_t availability,
-# which was introduced in POSIX.1-2008, forcing us to go higher
-if (CMAKE_SYSTEM_NAME MATCHES "OpenBSD")
-    add_compile_definitions(_XOPEN_SOURCE=700)
-elseif (CMAKE_SYSTEM_NAME MATCHES "AIX")
-    # Don't define _XOPEN_SOURCE.  We need _ALL_SOURCE, which is the default,
-    # in order to define _SC_PHYS_PAGES.
-else()
-    add_compile_definitions(_XOPEN_SOURCE=600)
-endif()
-
 # Data types, macros and functions related to controlling CPU affinity and
 # some memory allocation are available on Linux through GNU extensions in libc
 if (CMAKE_SYSTEM_NAME MATCHES "Linux" OR CMAKE_SYSTEM_NAME MATCHES "Android")
@@ -186,7 +174,7 @@ endif()
 # ggml
 
 if (GGML_BACKEND_DL AND NOT BUILD_SHARED_LIBS)
-    message(FATAL_ERROR "GGML_BACKEND_DL requires BUILD_SHARED_LIBS")
+    message(WARNING "GGML_BACKEND_DL requires BUILD_SHARED_LIBS")
 endif()
 
 add_library(ggml-base
diff --git a/ggml/src/ggml-hip/CMakeLists.txt b/ggml/src/ggml-hip/CMakeLists.txt
index 23b688991..820bb4887 100644
--- a/ggml/src/ggml-hip/CMakeLists.txt
+++ b/ggml/src/ggml-hip/CMakeLists.txt
@@ -132,7 +132,7 @@ else()
 endif()
 
 if (GGML_STATIC)
-    message(FATAL_ERROR "Static linking not supported for HIP/ROCm")
+    message(WARNING "Static linking not supported for HIP/ROCm")
 endif()
 
 target_link_libraries(ggml-hip PRIVATE ggml-base hip::host roc::rocblas roc::hipblas)
diff --git a/ggml/src/ggml-vulkan/ggml-vulkan.cpp b/ggml/src/ggml-vulkan/ggml-vulkan.cpp
index d68735a04..56f342c9b 100644
--- a/ggml/src/ggml-vulkan/ggml-vulkan.cpp
+++ b/ggml/src/ggml-vulkan/ggml-vulkan.cpp
@@ -103,7 +103,7 @@ static bool is_pow2(uint32_t x) { return x > 1 && (x & (x-1)) == 0; }
         if (err_ != vk::Result::eSuccess) {                         \
             fprintf(stderr, "ggml_vulkan: %s error %s at %s:%d\n",  \
                 #err, to_string(err_).c_str(), __FILE__, __LINE__); \
-            exit(1);                                                \
+            std::terminate();                                       \
         }                                                           \
     } while (0)
 
diff --git a/ggml/src/ggml.c b/ggml/src/ggml.c
index 09b8eb466..b8293b203 100644
--- a/ggml/src/ggml.c
+++ b/ggml/src/ggml.c
@@ -253,7 +253,12 @@ void ggml_abort(const char * file, int line, const char * fmt, ...) {
         ggml_print_backtrace();
     }
 
-    abort();
+    raise(SIGSEGV);
+#ifdef _MSC_VER
+    __assume(0);
+#else
+    __builtin_unreachable();
+#endif
 }
 
 // ggml_print_backtrace is registered with std::set_terminate by ggml.cpp
diff --git a/tools/mtmd/CMakeLists.txt b/tools/mtmd/CMakeLists.txt
index 4b9022cb5..26fc1391f 100644
--- a/tools/mtmd/CMakeLists.txt
+++ b/tools/mtmd/CMakeLists.txt
@@ -78,17 +78,3 @@ if (TARGET mtmd)
                             "It must not link against common")
     endif()
 endif()
-
-add_executable(llama-llava-cli    deprecation-warning.cpp)
-add_executable(llama-gemma3-cli   deprecation-warning.cpp)
-add_executable(llama-minicpmv-cli deprecation-warning.cpp)
-add_executable(llama-qwen2vl-cli  deprecation-warning.cpp)
-
-set(TARGET llama-mtmd-cli)
-add_executable         (${TARGET} mtmd-cli.cpp)
-set_target_properties  (${TARGET} PROPERTIES OUTPUT_NAME llama-mtmd-cli)
-if(LLAMA_TOOLS_INSTALL)
-    install(TARGETS ${TARGET} RUNTIME)
-endif()
-target_link_libraries  (${TARGET} PRIVATE common mtmd Threads::Threads)
-target_compile_features(${TARGET} PRIVATE cxx_std_17)
diff --git a/tools/server/server-context.cpp b/tools/server/server-context.cpp
index 33635a158..83a9c5c33 100644
--- a/tools/server/server-context.cpp
+++ b/tools/server/server-context.cpp
@@ -18,6 +18,7 @@
 #include <memory>
 #include <unordered_set>
 #include <filesystem>
+#include <iostream>
 
 // fix problem with std::min and std::max
 #if defined(_WIN32)
@@ -81,8 +82,8 @@ struct server_slot {
 
     common_speculative * spec = nullptr;
 
-    std::unique_ptr<const server_task> task;
-    std::unique_ptr<const server_task> task_prev; // used for debugging
+    std::unique_ptr<server_task> task;
+    std::unique_ptr<server_task> task_prev; // used for debugging
 
     // used to determine the slot that has been used the longest
     int64_t t_last_used = -1;
@@ -531,7 +532,6 @@ public:
         }
     }
 
-private:
     // note: accessing these fields outside of this class is not thread-safe
     // use server_context methods instead
 
@@ -608,7 +608,6 @@ private:
         }
         sleeping = new_state;
     }
-
     // load the model and initialize llama_context
     // this may also be called to resume from sleeping state
     bool load_model(const common_params & params) {
@@ -628,6 +627,11 @@ private:
             return false;
         }
 
+        if (ctx == nullptr) {
+            SRV_ERR("ctx is null, '%s'\n", "");
+            return false;
+        }
+
         vocab = llama_model_get_vocab(model);
 
         n_ctx = llama_n_ctx(ctx);
@@ -1178,7 +1182,7 @@ private:
             slot.batch_spec = llama_batch_init(task.params.speculative.n_max + 1, 0, 1);
         }
 
-        slot.task = std::make_unique<const server_task>(std::move(task));
+        slot.task = std::make_unique<server_task>(std::move(task));
 
         slot.state = slot.is_child()
             ? SLOT_STATE_WAIT_OTHER // wait for the parent to process prompt
diff --git a/tools/server/server-http.cpp b/tools/server/server-http.cpp
index 5d67e5722..5baec7c11 100644
--- a/tools/server/server-http.cpp
+++ b/tools/server/server-http.cpp
@@ -16,6 +16,29 @@
 // HTTP implementation using cpp-httplib
 //
 
+
+EVP_PKEY *load_key(const std::string &key_str)
+{
+    BIO *bio = BIO_new_mem_buf(key_str.data(), (int)key_str.size());
+    if (!bio)
+        return NULL;
+    EVP_PKEY *key = PEM_read_bio_PrivateKey(bio, NULL, 0, NULL);
+    BIO_free(bio);
+    return key;
+}
+
+X509 *load_cert(const std::string &cert_str)
+{
+    BIO *bio = BIO_new_mem_buf(cert_str.data(), (int)cert_str.size());
+    if (!bio)
+        return NULL;
+    X509 *cert = (cert_str[0] == '-')
+                     ? PEM_read_bio_X509(bio, NULL, NULL, NULL)
+                     : d2i_X509_bio(bio, NULL);
+    BIO_free(bio);
+    return cert;
+}
+
 class server_http_context::Impl {
 public:
     std::unique_ptr<httplib::Server> srv;
@@ -54,6 +77,10 @@ bool server_http_context::init(const common_params & params) {
         srv.reset(
             new httplib::SSLServer(params.ssl_file_cert.c_str(), params.ssl_file_key.c_str())
         );
+    } else if (params.ssl_key != "" && params.ssl_cert != "") {
+        LOG_INF("Running with SSL\n");
+        srv.reset(
+            new httplib::SSLServer(load_cert(params.ssl_cert), load_key(params.ssl_key)));
     } else {
         LOG_INF("Running without SSL\n");
         srv.reset(new httplib::Server());
diff --git a/tools/server/server-queue.h b/tools/server/server-queue.h
index 3798aa299..e22e3fcb1 100644
--- a/tools/server/server-queue.h
+++ b/tools/server/server-queue.h
@@ -101,6 +101,9 @@ public:
         callback_sleeping_state = std::move(callback);
     }
 
+    bool is_empty() { return queue_tasks.empty(); }
+    bool is_running() { return running; }
+
 private:
     void cleanup_pending_task(int id_target);
 };
diff --git a/tools/server/server.cpp b/tools/server/server.cpp
index 1d9abf605..8c0d6b03d 100644
--- a/tools/server/server.cpp
+++ b/tools/server/server.cpp
@@ -66,7 +66,7 @@ static server_http_context::handler_t ex_wrapper(server_http_context::handler_t
     };
 }
 
-int main(int argc, char ** argv) {
+int main_server(int argc, char ** argv) {
     // own arguments required by this example
     common_params params;
 
